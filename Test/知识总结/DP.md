1. 滚动数组优化
    ```
        j递增
      1 2 3 4
    1 o 
    2   o * x i递减
    3     * * 
    4       o
    ```
    用*来更新x 可以f[2][N]优化f[N][N]
    枚举顺序依更新顺序
    POJ1159：添加最少字符构成回文序列
    int p= i&1
    f[终止的i&1][N]
    ```cpp 
    for (int i = n; i >= 1; i--)
    {
        int p = i & 1;
        memset(f[p], 0, sizeof f[p]);//IMPORTANT
        for (int j = i + 1; j <= n; j++)
        {
            if (s[i] == s[j])
                f[p][j] = f[p ^ 1][j - 1];
            else
                f[p][j] = min(f[p ^ 1][j], f[p][j - 1]) + 1;
        }
    }
    ```
    * i-1和i-2更新i如下
    i%3 (i+1)%3 : i-2  (i+2)%3 : i-1

2. 背包
   1. 求$max_{select(i)} \Sigma_{i=1}a_i$
   约束形如<font color=#0099ff size = 4>$$\frac{\Sigma_{i=1}^{N}a_i}{\Sigma_{i=1}^{N}b_i}=k $$</font>等价于$\Sigma_{i=1}^{N}(a_i-kb_i)=0 $
   体积$V_i = a_i-kb_i $ 价值为$a_i$ 即背包为0时的最大价值的背包问题
    * 有正有负的偏移时，确定偏移值N 只需要在输出时输出f[N] 可以看成背包有N，就能避免负数体积时的问题   
   2. 经典拼硬币，面值和<1e5 每种硬币个数有限 问能拼成多少种面值的：即多重背包问题
      * 当成多重背包问题做，二进制优化转化为0-1背包 HDU2844 
      * 可以转化为有约束的完全背包，（特殊）POJ1742/p1537 比上面的方法快，很巧妙  
        ```cpp
        for (int i = 1; i <= n; i++)
        {
            memset(sum, 0, sizeof sum);
            for (int j = v[i]; j <= m; j++)
            {
                if (!f[j] && f[j - v[i]] && sum[j - v[i]] < c[i])
                {//如果此时面值为j还没有拼出来，如果j-v[i]拼了出来，且还有第i种硬币可以用，那么就用它 从而O（NM）时间复杂度解决了问题，比多重背包少了一层循环K
                    f[j] = 1, sum[j] = sum[j - v[i]] + 1;
                    ans++;
                }
            }
        }
        ``` 
    3. 【救火】CF864E 抢救的最大价值和多少，其中第i个物品需要ti时间，且di时间未抢救就消失
        * 先对时间di排序，因为考虑先消失的物品，取或者不取它应该先考虑
        * 方案转移：用vector v[i]=v[j]是深拷贝 可以直接赋值
        * 因为排序打乱顺序，所以要给每个物品一个id 
3. 状压dp
   1. 经典骨牌覆盖问题
   首先排除m×n是奇数，然后如果m比n大，交换m，n；
   先dfs得到状态，从而减少搜索量 并且给出最多可能有多少状态，从而防止mle
   2. 位运算
      1. x是不是s的子集  x|s == s
      2. n个元素，子集$|s|=k$， s是多少个集合的子集呢？ $ 2^{n-k} $ 因为其他的n-k个可以选或不选。 集合中有$ \dbinom{k}{n} $ 个$|s|=k$的子集。所以n个元素构成的全部可能的集合的所有的子集数目为$\Sigma_{k=0}^{n}\dbinom{k}{n}2^{n-k}*1^k=(1+2)^n=3^n $ 
      O(3^16)还可以 O（4^16）不行
      3. 子集枚举O(3^n)
      ```cpp
      for(int i=x;i;i=(i-1)&x)
      ```
4. 单调性优化
   1. 以p2885为例
      * 转移方程为$ f[i][j]=min(f[i-1][k]+(j-a[i])^2+c*|j-k|) $
        转化为
        $ f[i][j]=\left\{\begin{aligned} 
        min(f[i-1][k]-c*k)+c*j+(j-a[i])^2 \qquad j\ge k \\
        min(f[i-1][k]+c*k)-c*j+(j-a[i]^2) \qquad j\le k 
        \end{aligned}\right. $ 
        注意到存在单调性，因此，可以维护前一状态$p[j]=min(f[k]-c*k)\quad \forall k\le j  $ 写起来比单调队列、单调栈要简单
5. 期望dp
    1. p1850 其实就是转移的时候赋给转移边权一个概率,附加状态永远是对于i而言的，前ｉ个，ｊ表示第ｉ个怎么怎么样，不能说对ｉ－１发挥作用
    2. coupon Collection problem P4550  定义期望DP的一般形式为  一共要取N张，**目前取了i张**，**还有**n-i张要取 最终答案为f[0]，起始f[n]=0
       考虑一个状态f[i+1] 到另一个状态f[i] 的转移  f[i]有两个来源，目前取了i张，则有$i/n$的概率取到相同的，花费1次数回到了状态f[i]；有$(n-i)/n$的概率取到不同的，从f[i+1] 花费了1次数而转移过来 **注意到都要次数+1** 所以转移方程 $f[i]=\frac{i}{n}(f[i]+1)+\frac{n-i}{n}(f[i+1]+1)$ 
       考虑消费g[i] **目前取了i张**，**还有**n-i张要取的价格 g[i] 有两个来源 有$i/n$的概率取到相同的，花费在g[i]的基础上增加了f[i]+1 这是在g[i]状态下再抽一次的期望价格，同理，有$(n-i)/n$的概率取到不同的，在g[i+1]的基础上期望抽过了f[i+1]次，所以这次的价格是f[i+1]+1; 总的状态转移方程为 $g[i]=\frac{i}{n}(g[i]+f[i]+1)+\frac{n-i}{n}(g[i+1]+f[i+1]+1)$ 
    3. 有n个奖品,m个人排队选礼物。对于每个人,他打开的盒子可能有礼物,也可能已经被之前的人取走  了。如果有礼物,取走礼物然后把盒子放回原处。求最后所有人期望取走多少个礼物。
       定义状态为前i个人要去取，此时期望取到了礼物的个数f[i] 则f[0]=0,求f[m]
       i-1个人已经取过，期望取到了f[i-1]个礼物，所以第i个人取到礼物概率为$\frac{n-f[i-1]}{n}$ 自然转移方程为$f[i]=\frac{n-f[i-1]}{n}+f[i-1]$
    4. ZOJ3640 定义f[i]为战斗力为i时可以逃脱的期望天数  

6. 线性dp
    1. p1868 最长不相交线段和
    2. cf985e n个数分组每组至少k个数，每组里两个数绝对值差不超过d，求能否满足条件
       排序；转移状态采用正向递推，如果方案已经合法，不用再去更新这个方案 玄学把O（n^2)降下来
    3. hdu6024 在i处建不建装置，如果不建，枚举前一个建的  加上转移花费 原则O（n^2) 可能存在单调性优化      　
    4. cf414b 如果一个数列中，后一个数都能被前面一个数整除，那么就叫这个数列为好数列。求数列中最大元素不超过n，数列长度为k的好数列的种数
       f[i][j] 表示长度i，以j结尾的种数，f[i][j]=f[i-1][k_1]+f[i-1][k_2]+... k_i|j 可以转为正向递推，不用这样存因数
       f[i][j*l]+=f[i-1][j] 更新j的l倍 时间复杂度仍为O(n^2sqrt(n)) 但交上去5s变为3s 优化明显 
7. 数位dp
   * 状态要开全！！！！！！！！，状态要开全是指：bool量也是1维，不开会错，涉及到前导0的时候，把前导0情况下10传给pre，状态开f[11]
    1. 模板 hdu2089 《不要62》
       ```cpp
        typedef long long ll;
        ll dfs(int pos, int sta, bool eq) {
            if (pos == 0) return 1; //处理数到末尾时的 
            if (!eq && f[pos][sta] != -1) return f[pos][sta];//记忆过的状态，如果eq为真说明要重新数

            int ed = eq ? a[pos] : 9;//如果前一个是上界，那么这一个的上界为a[pos]
            ll ret = 0;//计数开始

            for (int i = 0;i <= ed;i++) {
                if (sta && i == 2) continue;
                if (i == 4) continue;

                ret += dfs(pos - 1, i == 6, eq && i == ed);
            }

            if (!eq) f[pos][sta] = ret;//记忆下来搜索树的分支f(pos,sta)以后重复使用
            return ret;
        }
        ll solve(ll x) {
            a[0] = 0;//注意清0！！！
            while (x) {
                a[++a[0]] = x % 10;
                x /= 10;
            }
            memset(f, -1, sizeof f);//注意初始化！！！
            return dfs(a[0], 0, true);
        }
        ll L, R;
        while (scanf("%lld %lld", &L, &R) && (L || R)) {
            if (L) {
                printf("%lld\n", solve(R) - solve(L - 1));//讨论一下起点是不是0
            }
            else {
                printf("%lld\n", solve(R) - solve(L));
            }
        }
       ```
    2. 前导0与上界
       ```cpp
       if (!eq && !lead && ~f[pos][pre]) return f[pos][pre]; //只有此时可以利用 
       if (!eq && !lead) f[pos][pre] = ret; //只有此时更新
       ```
       p3413 判断当前和前面两个数的比较时，因为前导0的存在，所以pre必须传的是10，我这种不加lead维的写法很容易搞错 
       p3303 `if (!lead && i == 0) continue; //中间状态出现了0； ` 表示的是前导0可以存在，但是中间不能有0，在数位乘积时用到
             而`if (lead && i == 0) ` 表示的是这个0是前导0，不参与统计，比如统计数位中0的个数时
    3. 容易写错的点
       1. 和dfs一样，注意恢复状态 P4124
       2. 终点时，先判断终点，再讨论return什么，不能写成一起！
       3. i<=ed 而不是9！！！容易手滑 （1）a[0]=0 （2） 注意0这个数可能要具体讨论 （3） f初始化-1 但有时不需要每次都初始化，可以在保证正确性但tle的情况下只进行1次
8. 树形dp
   1. 树上背包及优化
      1. n个点，每个点有点权 找m个点的子树，点权和最大： f(i,j)表示在子树i 取j个点的最大值 
         1. 优化1：这个优化最明显 第二层循环取min(待选的物品数量，背包大小）
         2. 优化2：第三层循环在 k<j 即小于背包容量下，还应小于可选总数 
         3. ```cpp
            void dfs(int root) {
                f[root][1] = b[root];
                sz[root] = 1;
                for (int i = 0;i < v[root].size();i++) {
                    int to = v[root][i];
                    dfs(to);
                    sz[root] += sz[to];

                }
                for (int i = 0;i < v[root].size();i++) {
                    int to = v[root][i];
                    for (int j = min(sz[root], m);j > 0;j--) {
                        // for (int k = 0;k < j && k <= sz[to];k++) {
                        for (int k = min(sz[to], j - 1);k >= 0;k--) {
                            f[root][j] = max(f[to][k] + f[root][j - k], f[root][j]);
                        }
                    }
                }
            }
            ```
    1.  两次dfs 
9. 前缀和优化
   1.  CF148E 给一个区间，每次只能从最左边或最右边拿1个，问拿k次最多拿多少 k要遍历一次用作后面分组背包
       实际上只需要定义1维f[i]表示拿i个 区间划分为前面j个，后面i-j个，前缀和O（1）转移