1. 滚动数组优化
    ```
        j递增
      1 2 3 4
    1 o 
    2   o * x i递减
    3     * * 
    4       o
    ```
    用*来更新x 可以f[2][N]优化f[N][N]
    枚举顺序依更新顺序
    POJ1159：添加最少字符构成回文序列
    int p= i&1
    f[终止的i&1][N]
    ```cpp 
    for (int i = n; i >= 1; i--)
    {
        int p = i & 1;
        memset(f[p], 0, sizeof f[p]);//IMPORTANT
        for (int j = i + 1; j <= n; j++)
        {
            if (s[i] == s[j])
                f[p][j] = f[p ^ 1][j - 1];
            else
                f[p][j] = min(f[p ^ 1][j], f[p][j - 1]) + 1;
        }
    }
    ```
    * i-1和i-2更新i如下
    i%3 (i+1)%3 : i-2  (i+2)%3 : i-1

2. 背包
   1. 求$max_{select(i)} \Sigma_{i=1}a_i$
   约束形如<font color=#0099ff size = 4>$$\frac{\Sigma_{i=1}^{N}a_i}{\Sigma_{i=1}^{N}b_i}=k $$</font>等价于$\Sigma_{i=1}^{N}(a_i-kb_i)=0 $
   体积$V_i = a_i-kb_i $ 价值为$a_i$ 即背包为0时的最大价值的背包问题
    * 有正有负的偏移时，确定偏移值N 只需要在输出时输出f[N] 可以看成背包有N，就能避免负数体积时的问题   
   2. 经典拼硬币，面值和<1e5 每种硬币个数有限 问能拼成多少种面值的：即多重背包问题
      * 当成多重背包问题做，二进制优化转化为0-1背包 HDU2844 
      * 可以转化为有约束的完全背包，（特殊）POJ1742 比上面的方法快，很巧妙  
        ```cpp
        for (int i = 1; i <= n; i++)
        {
            memset(sum, 0, sizeof sum);
            for (int j = v[i]; j <= m; j++)
            {
                if (!f[j] && f[j - v[i]] && sum[j - v[i]] < c[i])
                {//如果此时面值为j还没有拼出来，如果j-v[i]拼了出来，且还有第i种硬币可以用，那么就用它 从而O（NM）时间复杂度解决了问题，比多重背包少了一层循环K
                    f[j] = 1, sum[j] = sum[j - v[i]] + 1;
                    ans++;
                }
            }
        }
        ``` 
    3. 【救火】CF864E 抢救的最大价值和多少，其中第i个物品需要ti时间，且di时间未抢救就消失
        * 先对时间di排序，因为考虑先消失的物品，取或者不取它应该先考虑
        * 方案转移：用vector v[i]=v[j]是深拷贝 可以直接赋值
        * 因为排序打乱顺序，所以要给每个物品一个id 
3. 状压dp
   1. 经典骨牌覆盖问题
   首先排除m×n是奇数，然后如果m比n大，交换m，n；
   先dfs得到状态，从而减少搜索量 并且给出最多可能有多少状态，从而防止mle
   2. 位运算
      1. x是不是s的子集  x|s == s
      2. n个元素，子集$|s|=k$， s是多少个集合的子集呢？ $ 2^{n-k} $ 因为其他的n-k个可以选或不选。 集合中有$ \dbinom{k}{n} $ 个$|s|=k$的子集。所以n个元素构成的全部可能的集合的所有的子集数目为$\Sigma_{k=0}^{n}\dbinom{k}{n}2^{n-k}*1^k=(1+2)^n=3^n $ 
      O(3^16)还可以 O（4^16）不行
      3. 子集枚举O(3^n)
      ```cpp
      for(int i=x;i;i=(i-1)&x)
      ```
4. 单调性优化
   1. 以p2885为例
      * 转移方程为$ f[i][j]=min(f[i-1][k]+(j-a[i])^2+c*|j-k|) $
        转化为
        $ f[i][j]=\left\{\begin{aligned} 
        min(f[i-1][k]-c*k)+c*j+(j-a[i])^2 \qquad j\ge k \\
        min(f[i-1][k]+c*k)-c*j+(j-a[i]^2) \qquad j\le k 
        \end{aligned}\right. $ 
        注意到存在单调性，因此，可以维护前一状态$p[j]=min(f[k]-c*k)\quad \forall k\le j  $ 写起来比单调队列、单调栈要简单
5. 期望dp
    1. p1850 其实就是转移的时候赋给转移边权一个概率,附加状态永远是对于i而言的，前ｉ个，ｊ表示第ｉ个怎么怎么样，不能说对ｉ－１发挥作用
    　　